[{"id":0,"href":"/docs/chapter04/etltool/","title":"ETL 工具","section":"第四章-数据联邦","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":1,"href":"/docs/chapter08/linuxoptimize/","title":"Linux 优化","section":"第八章-性能优化","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":2,"href":"/docs/chapter04/synctool/mysqlsync/","title":"Mysql 同步工具","section":"数据同步工具","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":3,"href":"/docs/chapter04/synctool/oraclesync/","title":"Oracle数据同步工具","section":"数据同步工具","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":4,"href":"/docs/","title":"第一章-关于作者","section":"第一章-关于作者","content":" 关于作者 # Hi FortuneXu 👋👋 🔭 🔭 # The author focuses on sharing practical content on PostgreSQL and Greenplum. Welcome to read and subscribe. Thank you for your feedback on the issue.\nGitHub Stats # GitHub Readme Card # "},{"id":5,"href":"/docs/chapter01/","title":"第一章-关于作者","section":"第一章-关于作者","content":" 关于作者 # Hi FortuneXu 👋👋 🔭 🔭 # The author focuses on sharing practical content on PostgreSQL and Greenplum. Welcome to read and subscribe. Thank you for your feedback on the issue.\nGitHub Stats # GitHub Readme Card # "},{"id":6,"href":"/docs/chapter08/sqloptimize/","title":"SQL 优化","section":"第八章-性能优化","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":7,"href":"/docs/chapter03/clientconnection/","title":"客户端连接数据库","section":"第三章-数据库使用","content":" 客户端接入 # 客户端驱动下载 # 建议选择与 PostgreSQL 与 Greenplum 兼容的驱动。\nPostgreSQL 官方驱动\nGreenplum 官方驱动\n常见链接工具使用 # DBeaver # DBeaver 中文文档 DbVisualizer # DbVisualizer 客户端连接软件 Navicat # 客户端管理工具navicat下载 Tableplus # Tableplus SmartSQL # SmartSQL 客户端 pgAdmin # pgadmin 客户端 DataGrip # DataGrip 客户端 HHDBCS # HHDBCS 恒辉通用数据库管理桌面软件 Antares SQL # Antares SQL 数据库管理软件 各自的特点比较 # 产品名称 版权 兼容性 是否支持开源版本 函数 分区表 流畅性 资源占用 DBeaver 商业/开源 GPDB5/6 支持 支持良好 支持 一般 较大 DataGrip 商业 GPDB5/6 支持 支持良好 支持 较好 较大 Navicat 商业 GPDB5/6 支持 支持一般 不支持 很好 一般 HHDBCS 开源 GPDB5/6 支持 支持良好 支持 很好 一般 "},{"id":8,"href":"/docs/chapter02/","title":"第二章-关于文档","section":"第一章-关于作者","content":" 关于文档 # 主要分享作者在工作中与客户交流所梳理的一些知识，为了能够把知识汇总在一起，避免查找资料而耽误时间，故而整理了此文档。作者在工作中使用Greenplum和PostgreSQL数据库的经验进行分享，其中文档中涉及的内容较多，干货多多，欢迎star ⭐🏻 ，也欢迎大家对内容及时提ISSUE。✿✿ヽ(°▽°)ノ✿ ✿✿ヽ(°▽°)ノ✿\n建站工具 # Hugo\nhugo-book-repo\nhugo-book\n常用资料 # PostgreSQL 系列 # PostgreSQL 中文文档\nPostgreSQL 官方文档\nPostgreSQL Wiki\nPostgreSQL param\nPostgreSQL 技术内幕\nGreenplum 系列 # tanzu-greenplum7\nGreenplum 官方ISSUE文档\nGreenplum Database v6.24 Documentation\nGreenplum 中文 # Greenplum 中文文档 Cloudberry # Apache Cloudberry\nApache Cloudberry 中文\n公众号推荐 # PostgreSQL学徒 PostgreSQL中文社区 CP的PostgreSQL厨房 陈淼的Greenplum公众号 红石PG PolarDB "},{"id":9,"href":"/docs/chapter04/managementtool/","title":"管理工具","section":"第四章-数据联邦","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":10,"href":"/docs/chapter04/synctool/","title":"数据同步工具","section":"第四章-数据联邦","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":11,"href":"/docs/chapter03/","title":"第三章-数据库使用","section":"第一章-关于作者","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":12,"href":"/docs/chapter03/codeconnection/","title":"编程语言连接数据库","section":"第三章-数据库使用","content":" 编程语言连接数据库 # 目前数据库一般支持HA的连接，即一个Coordinator内的一个节点异常后会链接到另外的一个节点，不会影响业务的正常运行。在JDBC配置时需要采用 高可用链接字符串(Connection URL/DSN) 的方式连接。适用于不同的编程语言中使用，URL例如:\npostgres://username1:password1@CoordinatorIP:CoordinatorPort,CoordinatorIP:CoordinatorPort/database?sslmode=disable username1: Coordinator1数据库用户名\npassword1: Coordinator1数据库密码\nCoordinatorIP: Coordinator1数据库IP\nCoordinatorPort: Coordinator1数据库端口\ndatabase: 数据库名\nsslmode: 表示是否启用 SSL 连接。\nURL 高级连接参数 # 插入数据时的参数 # 如果在批量加载数据时需要添加以下的参数，为了在加载数据时按照batchSize进行批量写入，可以添加以下参数：\npreferQueryMode=simple\u0026amp;reWriteBatchedInserts=true preferQueryMode: 指定使用哪种模式来执行对数据库的查询：simple 表示（Q执行，不解析，不绑定，仅文本模式），extended 表示始终使用绑定 / 执行消息，extendedForPrepared 表示仅对预编译语句使用 extended 模式，endedCacheEverything 表示使用扩展协议并尝试在查询缓存中缓存每一条语句（包括 Statement.execute (String sql)）。取值为 extended | extendedForPrepared | extendedCacheEverything | simple 。\nreWriteBatchedInserts: 这会将批量插入语句从 insert into foo (col1, col2, col3) values (1, 2, 3) 改为 insert into foo (col1, col2, col3) values (1, 2, 3), (4, 5, 6)，这样能提升 2 - 3 倍的性能。\n在高并发读取时的参数 # preparedStatementCacheQueries=512\u0026amp;defaultRowFetchSize=500\u0026amp;prepareThreshold=10 preparedStatementCacheQueries：一个会话中最大能缓存的PreparedStatement数量，默认值256，在高并发读取时可以适当调整为512.\ndefaultRowFetchSize：每次以游标的形式从数据库中获取的行数，默认值0不限制，可以适当调整为500，每次获取500行。\nprepareThreshold：确定在切换到使用服务器端预编译语句之前，PreparedStatement所需的执行次数。默认值为 5，这意味着在同一个PreparedStatement对象执行第 5 次时开始使用服务器端预编译语句。\nPostgreSQL JDBC 官方参数详解\nJAVA 链接案例 # 驱动下载 # 建议选择使用与 PostgreSQL 与 Greenplum 兼容的驱动。\nPostgreSQL 官方驱动\nGreenplum 官方驱动\nPostgreSQL® Extensions to the JDBC API\n连接案例 # Java JDBC 操作代码示例 Python 链接案例 # 驱动下载 # Python 官方驱动 # 轻量版驱动 pip install psycopg2-binary # 本地编译 pip install psycopg2 链接案例 # import psycopg2 # 1. 连接数据库（替换为你的实际参数） conn = psycopg2.connect( host=\u0026#34;localhost\u0026#34;, database=\u0026#34;testdb\u0026#34;, user=\u0026#34;postgres\u0026#34;, password=\u0026#34;yourpassword\u0026#34; ) # 2. 创建游标 cur = conn.cursor() # 3. 创建表（如果不存在） cur.execute(\u0026#34;\u0026#34;\u0026#34; CREATE TABLE IF NOT EXISTS users ( id SERIAL PRIMARY KEY, name VARCHAR(100), email VARCHAR(100) UNIQUE ) \u0026#34;\u0026#34;\u0026#34;) # 4. 插入一条数据 cur.execute( \u0026#34;INSERT INTO users (name, email) VALUES (%s, %s)\u0026#34;, (\u0026#34;Alice\u0026#34;, \u0026#34;alice@example.com\u0026#34;) ) # 5. 查询数据 cur.execute(\u0026#34;SELECT * FROM users\u0026#34;) rows = cur.fetchall() for row in rows: print(f\u0026#34;ID: {row[0]}, Name: {row[1]}, Email: {row[2]}\u0026#34;) # 6. 关闭连接 conn.commit() # 提交事务 cur.close() conn.close() Go 链接案例 # 驱动下载 # pgx 是一个用于 PostgreSQL 的纯 Go 语言驱动程序和工具包。\n链接案例 # package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/jackc/pgx/v5\u0026#34; ) func main() { // urlExample := \u0026#34;postgres://username:password@localhost:5432/database_name\u0026#34; conn, err := pgx.Connect(context.Background(), os.Getenv(\u0026#34;DATABASE_URL\u0026#34;)) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;Unable to connect to database: %v\\n\u0026#34;, err) os.Exit(1) } defer conn.Close(context.Background()) var name string var weight int64 err = conn.QueryRow(context.Background(), \u0026#34;select name, weight from widgets where id=$1\u0026#34;, 42).Scan(\u0026amp;name, \u0026amp;weight) if err != nil { fmt.Fprintf(os.Stderr, \u0026#34;QueryRow failed: %v\\n\u0026#34;, err) os.Exit(1) } fmt.Println(name, weight) } 如果对与兼容性要求高，性能不是很高的场景可以使用 pg 的连接驱动。\nC 链接案例 # 建议使用 psqlODBC 的驱动连接 PostgreSQL 。下载并配置驱动的方式如下：\n驱动下载 # sudo yum install -y unixODBC unixODBC-devel postgresql-odbc 配置驱动 # 在etc/下创建件odbcinst.ini和odbc.ini配置文件内容如下:\n# cat /etc/odbcinst.ini [PostgreSQL] Description = ODBC for PostgreSQL Driver = /usr/lib/psqlodbcw.so Setup = /usr/lib/libodbcpsqlS.so Driver64 = /usr/lib64/psqlodbcw.so Setup64 = /usr/lib64/libodbcpsqlS.so FileUsage = 1 # cat /etc/odbc.ini [pg] Description = Test to pg Driver = PostgreSQL Database = test # Servername 集群的 Master,Standby的IP地址 Servername = \u0026lt;Master,Standby\u0026gt; UserName = username Password = password # Master,Standby 的集群端口 Port = \u0026lt;Master Port,Standby Port\u0026gt; ReadOnly = 0 C 链接代码 # 编写odbc_test.c代码，案例如下：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sql.h\u0026gt; #include \u0026lt;sqlext.h\u0026gt; void check_error(SQLRETURN ret, SQLHANDLE handle, SQLSMALLINT type) { if (!SQL_SUCCEEDED(ret)) { SQLCHAR sqlstate[6], message[256]; SQLSMALLINT len; SQLError(handle, type, sqlstate, NULL, message, sizeof(message), \u0026amp;len); fprintf(stderr, \u0026#34;ERROR: %s (SQLSTATE %s)\\n\u0026#34;, message, sqlstate); exit(1); } } int main() { SQLHENV env; SQLHDBC dbc; SQLHSTMT stmt; SQLRETURN ret; SQLCHAR connstr[] = \u0026#34;DSN=testdb\u0026#34;; // 1. 初始化环境 SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, \u0026amp;env); SQLSetEnvAttr(env, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0); // 2. 建立连接 SQLAllocHandle(SQL_HANDLE_DBC, env, \u0026amp;dbc); ret = SQLDriverConnect(dbc, NULL, connstr, SQL_NTS, NULL, 0, NULL, SQL_DRIVER_COMPLETE); check_error(ret, dbc, SQL_HANDLE_DBC); // 3. 创建表 SQLAllocHandle(SQL_HANDLE_STMT, dbc, \u0026amp;stmt); SQLExecDirect(stmt, \u0026#34;CREATE TABLE IF NOT EXISTS users(id SERIAL PRIMARY KEY, name VARCHAR(50))\u0026#34;, SQL_NTS); printf(\u0026#34;Table created\\n\u0026#34;); // 4. 插入数据 SQLExecDirect(stmt, \u0026#34;INSERT INTO users(name) VALUES (\u0026#39;CentOS User\u0026#39;)\u0026#34;, SQL_NTS); printf(\u0026#34;Data inserted\\n\u0026#34;); // 5. 查询数据 SQLExecDirect(stmt, \u0026#34;SELECT * FROM users\u0026#34;, SQL_NTS); SQLCHAR name[50]; while (SQLFetch(stmt) == SQL_SUCCESS) { SQLGetData(stmt, 2, SQL_C_CHAR, name, sizeof(name), NULL); printf(\u0026#34;User: %s\\n\u0026#34;, name); } // 6. 清理资源 SQLFreeHandle(SQL_HANDLE_STMT, stmt); SQLDisconnect(dbc); SQLFreeHandle(SQL_HANDLE_DBC, dbc); SQLFreeHandle(SQL_HANDLE_ENV, env); return 0; } C# 连接案例 # 驱动下载 # sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm sudo yum install -y dotnet-sdk-6.0 链接案例 # 创建项目并编写代码\ndotnet new console -n PgOdbcDemo cd PgOdbcDemo 编辑 Program.cs 文件\nusing System; using System.Data.Odbc; class Program { static void Main() { // 使用DSN或直接连接字符串 string connStr = \u0026#34;Dsn=testdb;\u0026#34;; using (var conn = new OdbcConnection(connStr)) { conn.Open(); Console.WriteLine(\u0026#34;Connected to PostgreSQL via ODBC\u0026#34;); // 查询版本 var cmd = new OdbcCommand(\u0026#34;SELECT version(), current_user\u0026#34;, conn); using (var reader = cmd.ExecuteReader()) { while (reader.Read()) { Console.WriteLine($\u0026#34;Version: {reader[0]}\u0026#34;); Console.WriteLine($\u0026#34;Current User: {reader[1]}\u0026#34;); } } } } } 运行项目 # dotnet run Ruby 连接案例 # 驱动下载 # 推荐使用 ruby-pg作为Ruby的PostgreSQL驱动。\n要求Ruby 2.7 及以上版本。 PostgreSQL 10 及以上版本。\nyum install -y gem gem install pg -- --with-pg-config=\u0026lt;path to pg_config\u0026gt; bundle config build.pg --with-pg-config=\u0026lt;path to pg_config\u0026gt; 链接案例 # #!/usr/bin/env ruby require \u0026#39;pg\u0026#39; # Output a table of current connections to the DB conn = PG.connect( dbname: \u0026#39;sales\u0026#39; ) conn.exec( \u0026#34;SELECT * FROM pg_stat_activity\u0026#34; ) do |result| puts \u0026#34; PID | User | Query\u0026#34; result.each do |row| puts \u0026#34; %7d | %-16s | %s \u0026#34; % row.values_at(\u0026#39;pid\u0026#39;, \u0026#39;usename\u0026#39;, \u0026#39;query\u0026#39;) end end Rust 连接案例 # 驱动下载 # 推荐使用 rust-postgres 作为数据库的连接驱动。\n链接案例 # use tokio_postgres::{NoTls, Error}; async fn main() -\u0026gt; Result\u0026lt;(), Error\u0026gt; { let conn_str = \u0026#34;host=localhost user=your_username password=your_password dbname=your_dbname\u0026#34;; let (client, connection) = tokio_postgres::connect(conn_str, NoTls).await?; tokio::spawn(async move { if let Err(e) = connection.await { eprintln!(\u0026#34;连接池错误: {}\u0026#34;, e); } }); println!(\u0026#34;连接成功！\u0026#34;); let stmt = client.prepare(\u0026#34;SELECT version();\u0026#34;).await?; let rows = client.query(\u0026amp;stmt, \u0026amp;[]).await?; for row in rows { let version: String = row.get(0); println!(\u0026#34;PostgreSQL版本: {}\u0026#34;, version); } Ok(()) } NodeJS 连接案例 # 驱动下载 # 推荐使用 postgres作为链接驱动。\n$ npm install postgres 链接案例 # 推荐使用 Async/Await 的方法。\nconst { Client } = require(\u0026#39;pg\u0026#39;); async function main() { const client = new Client({ host: \u0026#39;localhost\u0026#39;, user: \u0026#39;postgres\u0026#39;, password: \u0026#39;yourpassword\u0026#39;, database: \u0026#39;testdb\u0026#39;, }); try { await client.connect(); await client.query(\u0026#39;BEGIN\u0026#39;); const insertRes = await client.query( \u0026#39;INSERT INTO users (name) VALUES ($1) RETURNING id\u0026#39;, [\u0026#39;Bob\u0026#39;] ); await client.query(\u0026#39;COMMIT\u0026#39;); console.log(\u0026#39;Inserted ID:\u0026#39;, insertRes.rows[0].id); } catch (err) { await client.query(\u0026#39;ROLLBACK\u0026#39;); console.error(\u0026#39;Error:\u0026#39;, err); } finally { await client.end(); } } main(); PHP 连接案例 # 驱动下载 # 驱动建议安装7.4 及以上的版本。\n# 安装驱动 sudo yum install php-pgsql # 验证安装的驱动 php -m | grep pgsql 链接案例 # \u0026lt;?php $host = \u0026#39;localhost\u0026#39;; $dbname = \u0026#39;testdb\u0026#39;; $user = \u0026#39;postgres\u0026#39;; $password = \u0026#39;yourpassword\u0026#39;; try { $pdo = new PDO(\u0026#34;pgsql:host=$host;dbname=$dbname\u0026#34;, $user, $password, [ PDO::ATTR_ERRMODE =\u0026gt; PDO::ERRMODE_EXCEPTION, PDO::ATTR_PERSISTENT =\u0026gt; true, PDO::ATTR_TIMEOUT =\u0026gt; 5 ]); $pdo-\u0026gt;exec(\u0026#34; CREATE TABLE IF NOT EXISTS users ( id SERIAL PRIMARY KEY, name VARCHAR(100), email VARCHAR(100) UNIQUE ) \u0026#34;); $stmt = $pdo-\u0026gt;prepare(\u0026#34;INSERT INTO users (name, email) VALUES (?, ?)\u0026#34;); $stmt-\u0026gt;execute([\u0026#39;Alice\u0026#39;, \u0026#39;alice@example.com\u0026#39;]); echo \u0026#34;Inserted ID: \u0026#34; . $pdo-\u0026gt;lastInsertId() . \u0026#34;\\n\u0026#34;; $stmt = $pdo-\u0026gt;query(\u0026#34;SELECT * FROM users\u0026#34;); while ($row = $stmt-\u0026gt;fetch(PDO::FETCH_ASSOC)) { echo \u0026#34;ID: {$row[\u0026#39;id\u0026#39;]}, Name: {$row[\u0026#39;name\u0026#39;]}\\n\u0026#34;; } } catch (PDOException $e) { die(\u0026#34;Error: \u0026#34; . $e-\u0026gt;getMessage()); } ?\u0026gt; Perl 连接案例 # 驱动下载 # 建议使用Perl5 的5.40.0 及更高版本\n# Debian/Ubuntu 安装方式 sudo apt-get install libdbd-pg-perl # CentOS/RHEL 安装方式 sudo yum install perl-DBD-Pg 链接案例 # #!/usr/bin/perl use strict; use warnings; use DBI; my $dsn = \u0026#34;DBI:Pg:dbname=testdb;host=localhost;port=5432\u0026#34;; my $user = \u0026#34;postgres\u0026#34;; my $password = \u0026#34;yourpassword\u0026#34;; my $dbh = DBI-\u0026gt;connect($dsn, $user, $password, { RaiseError =\u0026gt; 1, # 自动报错 AutoCommit =\u0026gt; 0, # 关闭自动提交（启用事务） pg_server_prepare =\u0026gt; 1 # 启用服务器端预处理 }) or die $DBI::errstr; $dbh-\u0026gt;do(\u0026lt;\u0026lt;\u0026#39;SQL\u0026#39;); CREATE TABLE IF NOT EXISTS users ( id SERIAL PRIMARY KEY, name VARCHAR(100), email VARCHAR(100) UNIQUE ) SQL my $insert = $dbh-\u0026gt;prepare( \u0026#34;INSERT INTO users (name, email) VALUES (?, ?) RETURNING id\u0026#34; ); $insert-\u0026gt;execute(\u0026#39;Alice\u0026#39;, \u0026#39;alice@example.com\u0026#39;); my $new_id = $insert-\u0026gt;fetchrow_arrayref-\u0026gt;[0]; print \u0026#34;Inserted ID: $new_id\\n\u0026#34;; my $sth = $dbh-\u0026gt;prepare(\u0026#34;SELECT * FROM users\u0026#34;); $sth-\u0026gt;execute(); while (my $row = $sth-\u0026gt;fetchrow_hashref) { print \u0026#34;ID: $row-\u0026gt;{id}, Name: $row-\u0026gt;{name}\\n\u0026#34;; } $dbh-\u0026gt;commit; $sth-\u0026gt;finish; $dbh-\u0026gt;disconnect; Excel 链接数据库 # 驱动下载 # 建议从 psqlODBC 驱动安装包下载ODBC 驱动。\n链接案例 # 链接案例请参考 使用 Excel 访问 PostgreSQL\n"},{"id":13,"href":"/docs/chapter04/","title":"第四章-数据联邦","section":"第一章-关于作者","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":14,"href":"/docs/chapter05/","title":"第五章-监控与维护","section":"第一章-关于作者","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":15,"href":"/docs/chapter06/","title":"第六章-故障诊断","section":"第一章-关于作者","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":16,"href":"/docs/chapter07/","title":"第七章-数据库生态","section":"第一章-关于作者","content":" 数据库生态 # dbsyncer 数据同步工具 # DBSyncer（简称dbs）是一款开源的数据同步中间件，提供MySQL、Oracle、SqlServer、PostgreSQL、Elasticsearch(ES)、Kafka、File、SQL等同步场景。支持上传插件自定义同步转换业务，提供监控全量和增量数据统计图、应用性能预警等。\n"},{"id":17,"href":"/docs/chapter08/","title":"第八章-性能优化","section":"第一章-关于作者","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":18,"href":"/docs/chapter09/","title":"第九章-分析工具","section":"第一章-关于作者","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":19,"href":"/docs/chapter10/","title":"第十章-服务流程","section":"第一章-关于作者","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":20,"href":"/docs/chapter11/","title":"第十一章-交付流程","section":"第一章-关于作者","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":21,"href":"/docs/chapter12/","title":"第十二章-售后服务流程","section":"第一章-关于作者","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":22,"href":"/docs/chapter13/","title":"第十三章-常见问题FAQ","section":"第一章-关于作者","content":" 关于文档 # Mainly sharing practical experience in the project, helping more people quickly obtain the necessary information, making the cluster more stable and efficient.\n搭站工具 # Hugo hugo-book-repo hugo-book 常用学习资料 # PostgreSQL 系列 # PostgreSQL 中文文档 PostgreSQL 官方文档 PostgreSQL Wiki "},{"id":23,"href":"/docs/chapter14/","title":"第十四章-DB差异对比","section":"第一章-关于作者","content":" DB 差异对比 # MySQL VS PostgreSQL # mysql - postgresql "},{"id":24,"href":"/docs/example/","title":"Example Site","section":"第一章-关于作者","content":" Introduction # Ferre hinnitibus erat accipitrem dixi Troiae tollens # Lorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\nPedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret Est simul fameque tauri qua ad # Locum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol # Nec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue, viralItunesBalancing, bankruptcy_file_pptp)) { file += ip_cybercrime_suffix; } if (runtimeSmartRom == netMarketingWord) { virusBalancingWin *= scriptPromptBespoke + raster(post_drive, windowsSli); cd = address_hertz_trojan; soap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui); } else { megabyte.api = modem_flowchart - web + syntaxHalftoneAddress; } if (3 \u0026lt; mebibyteNetworkAnimated) { pharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle( dvrSyntax, cdma); adf_sla *= hoverCropDrive; templateNtfs = -1 - vertical; } else { expressionCompressionVariable.bootMulti = white_eup_javascript( table_suffix); guidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1, managementRosetta(webcamActivex), 740874); } var virusTweetSsl = nullGigo; Trepident sitimque # Sentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\nExample # MacOS MacOS # This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux Linux # This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows Windows # This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nExample # Get Home Contribute # Example # Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\nMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\nMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\nExample # {{% columns [ratio=\u0026#34;1:1\u0026#34;] [class=\u0026#34;...\u0026#34;] %}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{% /columns %}} Left Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nMid Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!\nRight Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nSettings size ratio for columns # {{% columns ratio=\u0026#34;1:2\u0026#34; %}} \u0026lt;!-- begin columns block --\u0026gt; ## x1 Column Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; ## x2 Column Lorem markdownum insigne... {{% /columns %}} x1 Column # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nx2 Column # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"}]